{"ast":null,"code":"import * as PiecesActions from '../state/state.actions';\nimport { getTurns, getBoardSquares, getPieces } from '../state/state.selector';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nimport * as i2 from \"./pawn.service\";\nimport * as i3 from \"./rook.service\";\nimport * as i4 from \"./knight.service\";\nimport * as i5 from \"./bishop.service\";\nimport * as i6 from \"./queen.service\";\nimport * as i7 from \"./king.service\";\nexport let PieceService = /*#__PURE__*/(() => {\n  class PieceService {\n    constructor(store, pawnService, rookService, knightService, bishopService, queenService, kingService) {\n      this.store = store;\n      this.pawnService = pawnService;\n      this.rookService = rookService;\n      this.knightService = knightService;\n      this.bishopService = bishopService;\n      this.queenService = queenService;\n      this.kingService = kingService;\n      this.pieces = [];\n      this.boardSquares = [];\n      this.turns = 0;\n      this.pieces$ = this.store.select(getPieces);\n      this.pieces$.subscribe(pieces$ => this.pieces = [...pieces$]);\n      this.boardSquare$ = this.store.select(getBoardSquares);\n      this.boardSquare$.subscribe(boardSquare$ => this.boardSquares = [...boardSquare$]);\n      this.turn$ = this.store.select(getTurns);\n      this.turn$.subscribe(turn$ => this.turns = turn$);\n    } // Render position based on which possible move the piece\n    // is dragged, or dropped, closest to.\n\n\n    renderPosition(curPos, curPiece, moves) {\n      const {\n        x: curX,\n        y: curY\n      } = curPos;\n      let closestPos = {\n        x: curX,\n        y: curY\n      };\n      let closestDist = Number.MAX_SAFE_INTEGER;\n\n      for (const move of moves) {\n        const {\n          x,\n          y\n        } = move;\n        const distance = Math.sqrt(Math.pow(Math.abs(x - curX), 2) + Math.pow(Math.abs(y - curY), 2));\n\n        if (distance < closestDist) {\n          closestDist = distance;\n          closestPos = {\n            x,\n            y\n          };\n        }\n      }\n\n      return closestPos;\n    }\n\n    // Get all possible moves for the respective piece.\n    getPossibleMoves(piece, pieces) {\n      const playersTurn = this.turns % 2 === 0 ? 'white' : 'black'; // Base case for if it is not the piece's respective\n      // color's turn.\n\n      if (piece.color !== playersTurn) {\n        const curSquare = this.boardSquares.filter(({\n          square\n        }) => square === piece.location)[0];\n        return [curSquare];\n      }\n\n      const res = [];\n      const {\n        type\n      } = piece;\n\n      switch (type) {\n        case 'pawn':\n          res.push(...this.pawnService.getViablePos(piece, pieces));\n          break;\n\n        case 'rook':\n          res.push(...this.rookService.getViablePos(piece, pieces));\n          break;\n\n        case 'knight':\n          res.push(...this.knightService.getViablePos(piece, pieces));\n          break;\n\n        case 'bishop':\n          res.push(...this.bishopService.getViablePos(piece, pieces));\n          break;\n\n        case 'queen':\n          res.push(...this.queenService.getViablePos(piece, pieces));\n          break;\n\n        case 'king':\n          res.push(...this.kingService.getViablePos(piece, pieces));\n          break;\n      }\n\n      return res;\n    } // Filter all respective moves from possible moves that would\n    // result in the piece's respective king being in check.\n\n\n    filterMoves(curPiece, moves, pieces, boardSquares) {\n      const res = [];\n      const allPiecesExcluding = pieces.filter(({\n        name\n      }) => name !== curPiece.name);\n\n      for (const move of moves) {\n        const newPieces = [...allPiecesExcluding // Filter simulate a piece being taken by the respective move.\n        .filter(({\n          location\n        }) => location !== move.square), Object.assign(Object.assign({}, curPiece), {\n          location: move.square\n        })];\n        const inCheck = this.inCheck(newPieces, boardSquares);\n        if (!inCheck || move.square === curPiece.location) res.push(move);\n      }\n\n      return res;\n    }\n\n    inCheck(pieces, boardSquares) {\n      const playersTurn = this.turns % 2 !== 0 ? 'black' : 'white';\n      const posCaptureMoves = this.captureVectors(pieces, pieces.filter(({\n        color\n      }) => color !== playersTurn), boardSquares);\n      const king = pieces.filter(({\n        color,\n        type\n      }) => color === playersTurn && type === 'king')[0];\n      const check = posCaptureMoves.filter(({\n        square\n      }) => square === king.location).length > 0;\n      return check;\n    }\n\n    inCheckMate(turns, pieces, boardSquares) {\n      let checkMate = true;\n      const playersTurn = this.turns % 2 !== 0 ? 'black' : 'white';\n      const resPieces = pieces.filter(({\n        color\n      }) => color === playersTurn); // Can the checked kings pieces escape the check.\n\n      const checkedPieces = [...pieces.filter(({\n        color\n      }) => color !== playersTurn)]; // Get all possible moves for each checked piece.\n\n      for (let checkedPiece of checkedPieces) {\n        const moves = [];\n        const allPiecesExcluding = pieces.filter(({\n          name\n        }) => name !== checkedPiece.name);\n        const {\n          type\n        } = checkedPiece;\n\n        switch (type) {\n          case 'pawn':\n            moves.push(...this.pawnService.getViablePos(checkedPiece, pieces));\n            break;\n\n          case 'rook':\n            moves.push(...this.rookService.getViablePos(checkedPiece, pieces));\n            break;\n\n          case 'knight':\n            moves.push(...this.knightService.getViablePos(checkedPiece, pieces));\n            break;\n\n          case 'bishop':\n            moves.push(...this.bishopService.getViablePos(checkedPiece, pieces));\n            break;\n\n          case 'queen':\n            moves.push(...this.queenService.getViablePos(checkedPiece, pieces));\n            break;\n\n          case 'king':\n            moves.push(...this.kingService.getViablePos(checkedPiece, pieces));\n            break;\n\n          default:\n            break;\n        }\n\n        for (const move of moves) {\n          const curPiece = Object.assign(Object.assign({}, checkedPiece), {\n            location: move.square\n          });\n          const newPieces = [...allPiecesExcluding, curPiece];\n          const stillInCheck = this.inCheck(newPieces, boardSquares);\n\n          if (!stillInCheck) {\n            checkMate = false;\n            break;\n          }\n        }\n\n        resPieces.push(checkedPiece);\n      }\n\n      this.store.dispatch(PiecesActions.modifyPieces({\n        pieces: resPieces\n      }));\n      return checkMate;\n    }\n\n    captureVectors(allPieces, attackingPieces, boardSquares) {\n      const memo = {};\n      const checkVectors = [];\n\n      for (const piece of attackingPieces) {\n        const {\n          type,\n          location,\n          moved,\n          color\n        } = piece;\n        const col = location.split('')[0];\n        const row = Number(location.split('')[1]);\n        const res = [];\n\n        switch (type) {\n          case 'pawn':\n            res.push(...this.pawnService.positionsOfCheck(piece, boardSquares));\n            break;\n\n          case 'rook':\n            res.push(...this.rookService.getViablePos(piece, allPieces));\n            break;\n\n          case 'knight':\n            res.push(...this.knightService.getViablePos(piece, allPieces));\n            break;\n\n          case 'bishop':\n            res.push(...this.bishopService.getViablePos(piece, allPieces));\n            break;\n\n          case 'queen':\n            res.push(...this.queenService.getViablePos(piece, allPieces));\n            break;\n\n          case 'king':\n            res.push(...this.kingService.getViablePos(piece, allPieces));\n            break;\n\n          default:\n            break;\n        }\n\n        res.map(curSquare => {\n          if (!memo[curSquare.square]) {\n            memo[curSquare.square] = true;\n            checkVectors.push(curSquare);\n          }\n        });\n      }\n\n      return checkVectors;\n    }\n\n    castle(castlePieces) {\n      const {\n        king,\n        rook\n      } = castlePieces; // Base case.\n\n      if (!king || king.moved || !rook || rook.moved) return;\n      const side = rook.name.split('_')[1];\n\n      switch (side) {\n        case '1':\n          this.castleKingSide(king, rook);\n          break;\n\n        case '2':\n          this.castleQueenSide(king, rook);\n          break;\n      }\n    }\n\n    castleKingSide(king, rook) {\n      const row = king.location.split('')[1]; // Check that there is an open path\n      // to the king.\n\n      const leftOfKing = 'c' + row;\n      const canCastle = rook['moves'].filter(({\n        square\n      }) => square === leftOfKing)[0]; // Base case.\n\n      if (!canCastle) return; // Update king's location.\n\n      const kingPiece = this.pieces.filter(({\n        name\n      }) => name === king.name)[0];\n      const newKingPiece = Object.assign(Object.assign({}, kingPiece), {\n        location: 'c' + row\n      });\n      this.store.dispatch(PiecesActions.modifyPiece({\n        piece: newKingPiece,\n        turns: this.turns\n      })); // Update rook's location.\n\n      const rookPiece = this.pieces.filter(({\n        name\n      }) => name === rook.name)[0];\n      const newRookPiece = Object.assign(Object.assign({}, rookPiece), {\n        location: 'd' + row\n      });\n      this.store.dispatch(PiecesActions.modifyPiece({\n        piece: newRookPiece,\n        turns: this.turns\n      })); // Increment turns.\n\n      this.store.dispatch(PiecesActions.incrementTurn());\n    }\n\n    castleQueenSide(king, rook) {\n      const row = king.location.split('')[1]; // Check that there is an open path\n      // to the king.\n\n      const rightOfKing = 'e' + row;\n      const canCastle = rook['moves'].filter(({\n        square\n      }) => square === rightOfKing)[0]; // Base case.\n\n      if (!canCastle) return; // Update king's location.\n\n      const kingPiece = this.pieces.filter(({\n        name\n      }) => name === king.name)[0];\n      const newKingPiece = Object.assign(Object.assign({}, kingPiece), {\n        location: 'g' + row\n      });\n      this.store.dispatch(PiecesActions.modifyPiece({\n        piece: newKingPiece,\n        turns: this.turns\n      })); // Update rook's location.\n\n      const rookPiece = this.pieces.filter(({\n        name\n      }) => name === rook.name)[0];\n      const newRookPiece = Object.assign(Object.assign({}, rookPiece), {\n        location: 'f' + row\n      });\n      this.store.dispatch(PiecesActions.modifyPiece({\n        piece: newRookPiece,\n        turns: this.turns\n      })); // Increment turns.\n\n      this.store.dispatch(PiecesActions.incrementTurn());\n    }\n\n  }\n\n  PieceService.ɵfac = function PieceService_Factory(t) {\n    return new (t || PieceService)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.PawnService), i0.ɵɵinject(i3.RookService), i0.ɵɵinject(i4.KnightService), i0.ɵɵinject(i5.BishopService), i0.ɵɵinject(i6.QueenService), i0.ɵɵinject(i7.KingService));\n  };\n\n  PieceService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: PieceService,\n    factory: PieceService.ɵfac,\n    providedIn: 'root'\n  });\n  return PieceService;\n})();","map":null,"metadata":{},"sourceType":"module"}