{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nvar isWindows = process.platform === 'win32';\n\nvar util = require('util'); // resolves . and .. elements in a path array with directory names there\n// must be no slashes or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\n\n\nfunction normalizeArray(parts, allowAboveRoot) {\n  var res = [];\n\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]; // ignore empty parts\n\n    if (!p || p === '.') continue;\n\n    if (p === '..') {\n      if (res.length && res[res.length - 1] !== '..') {\n        res.pop();\n      } else if (allowAboveRoot) {\n        res.push('..');\n      }\n    } else {\n      res.push(p);\n    }\n  }\n\n  return res;\n} // returns an array with empty elements removed from either end of the input\n// array or the original array if no elements need to be removed\n\n\nfunction trimArray(arr) {\n  var lastIndex = arr.length - 1;\n  var start = 0;\n\n  for (; start <= lastIndex; start++) {\n    if (arr[start]) break;\n  }\n\n  var end = lastIndex;\n\n  for (; end >= 0; end--) {\n    if (arr[end]) break;\n  }\n\n  if (start === 0 && end === lastIndex) return arr;\n  if (start > end) return [];\n  return arr.slice(start, end + 1);\n} // Regex to split a windows path into three parts: [*, device, slash,\n// tail] windows-only\n\n\nvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/; // Regex to split the tail part of the above into [*, dir, basename, ext]\n\nvar splitTailRe = /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\nvar win32 = {}; // Function to split a filename into [root, dir, basename, ext]\n\nfunction win32SplitPath(filename) {\n  // Separate device+slash from tail\n  var result = splitDeviceRe.exec(filename),\n      device = (result[1] || '') + (result[2] || ''),\n      tail = result[3] || ''; // Split the tail into dir, basename and extension\n\n  var result2 = splitTailRe.exec(tail),\n      dir = result2[1],\n      basename = result2[2],\n      ext = result2[3];\n  return [device, dir, basename, ext];\n}\n\nfunction win32StatPath(path) {\n  var result = splitDeviceRe.exec(path),\n      device = result[1] || '',\n      isUnc = !!device && device[1] !== ':';\n  return {\n    device: device,\n    isUnc: isUnc,\n    isAbsolute: isUnc || !!result[2],\n    // UNC paths are always absolute\n    tail: result[3]\n  };\n}\n\nfunction normalizeUNCRoot(device) {\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\n} // path.resolve([from ...], to)\n\n\nwin32.resolve = function () {\n  var resolvedDevice = '',\n      resolvedTail = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1; i--) {\n    var path;\n\n    if (i >= 0) {\n      path = arguments[i];\n    } else if (!resolvedDevice) {\n      path = process.cwd();\n    } else {\n      // Windows has the concept of drive-specific current working\n      // directories. If we've resolved a drive letter but not yet an\n      // absolute path, get cwd for that drive. We're sure the device is not\n      // an unc path at this points, because unc paths are always absolute.\n      path = process.env['=' + resolvedDevice]; // Verify that a drive-local cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n\n      if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\\\') {\n        path = resolvedDevice + '\\\\';\n      }\n    } // Skip empty and invalid entries\n\n\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    var result = win32StatPath(path),\n        device = result.device,\n        isUnc = result.isUnc,\n        isAbsolute = result.isAbsolute,\n        tail = result.tail;\n\n    if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (!resolvedDevice) {\n      resolvedDevice = device;\n    }\n\n    if (!resolvedAbsolute) {\n      resolvedTail = tail + '\\\\' + resolvedTail;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedDevice && resolvedAbsolute) {\n      break;\n    }\n  } // Convert slashes to backslashes when `resolvedDevice` points to an UNC\n  // root. Also squash multiple slashes into a single one where appropriate.\n\n\n  if (isUnc) {\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\n  } // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when process.cwd()\n  // fails)\n  // Normalize the tail path\n\n\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/), !resolvedAbsolute).join('\\\\');\n  return resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail || '.';\n};\n\nwin32.normalize = function (path) {\n  var result = win32StatPath(path),\n      device = result.device,\n      isUnc = result.isUnc,\n      isAbsolute = result.isAbsolute,\n      tail = result.tail,\n      trailingSlash = /[\\\\\\/]$/.test(tail); // Normalize the tail path\n\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\n\n  if (!tail && !isAbsolute) {\n    tail = '.';\n  }\n\n  if (tail && trailingSlash) {\n    tail += '\\\\';\n  } // Convert slashes to backslashes when `device` points to an UNC root.\n  // Also squash multiple slashes into a single one where appropriate.\n\n\n  if (isUnc) {\n    device = normalizeUNCRoot(device);\n  }\n\n  return device + (isAbsolute ? '\\\\' : '') + tail;\n};\n\nwin32.isAbsolute = function (path) {\n  return win32StatPath(path).isAbsolute;\n};\n\nwin32.join = function () {\n  var paths = [];\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n\n    if (!util.isString(arg)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    if (arg) {\n      paths.push(arg);\n    }\n  }\n\n  var joined = paths.join('\\\\'); // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\n  }\n\n  return win32.normalize(joined);\n}; // path.relative(from, to)\n// it will solve the relative path from 'from' to 'to', for instance:\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\n\nwin32.relative = function (from, to) {\n  from = win32.resolve(from);\n  to = win32.resolve(to); // windows is not case sensitive\n\n  var lowerFrom = from.toLowerCase();\n  var lowerTo = to.toLowerCase();\n  var toParts = trimArray(to.split('\\\\'));\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (lowerFromParts[i] !== lowerToParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  if (samePartsLength == 0) {\n    return to;\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('\\\\');\n};\n\nwin32._makeLong = function (path) {\n  // Note: this will *probably* throw somewhere.\n  if (!util.isString(path)) return path;\n\n  if (!path) {\n    return '';\n  }\n\n  var resolvedPath = win32.resolve(path);\n\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n    // path is local filesystem path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\' + resolvedPath;\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n    // path is network UNC path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n  }\n\n  return path;\n};\n\nwin32.dirname = function (path) {\n  var result = win32SplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nwin32.basename = function (path, ext) {\n  var f = win32SplitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nwin32.extname = function (path) {\n  return win32SplitPath(path)[3];\n};\n\nwin32.format = function (pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" + typeof pathObject.root);\n  }\n\n  var dir = pathObject.dir;\n  var base = pathObject.base || '';\n\n  if (!dir) {\n    return base;\n  }\n\n  if (dir[dir.length - 1] === win32.sep) {\n    return dir + base;\n  }\n\n  return dir + win32.sep + base;\n};\n\nwin32.parse = function (pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\"Parameter 'pathString' must be a string, not \" + typeof pathString);\n  }\n\n  var allParts = win32SplitPath(pathString);\n\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\nwin32.sep = '\\\\';\nwin32.delimiter = ';'; // Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\n\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar posix = {};\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n} // path.resolve([from ...], to)\n// posix version\n\n\nposix.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path[0] === '/';\n  } // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path\n\n\n  resolvedPath = normalizeArray(resolvedPath.split('/'), !resolvedAbsolute).join('/');\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}; // path.normalize(path)\n// posix version\n\n\nposix.normalize = function (path) {\n  var isAbsolute = posix.isAbsolute(path),\n      trailingSlash = path && path[path.length - 1] === '/'; // Normalize the path\n\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n}; // posix version\n\n\nposix.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n}; // posix version\n\n\nposix.join = function () {\n  var path = '';\n\n  for (var i = 0; i < arguments.length; i++) {\n    var segment = arguments[i];\n\n    if (!util.isString(segment)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    if (segment) {\n      if (!path) {\n        path += segment;\n      } else {\n        path += '/' + segment;\n      }\n    }\n  }\n\n  return posix.normalize(path);\n}; // path.relative(from, to)\n// posix version\n\n\nposix.relative = function (from, to) {\n  from = posix.resolve(from).substr(1);\n  to = posix.resolve(to).substr(1);\n  var fromParts = trimArray(from.split('/'));\n  var toParts = trimArray(to.split('/'));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('/');\n};\n\nposix._makeLong = function (path) {\n  return path;\n};\n\nposix.dirname = function (path) {\n  var result = posixSplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nposix.basename = function (path, ext) {\n  var f = posixSplitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nposix.extname = function (path) {\n  return posixSplitPath(path)[3];\n};\n\nposix.format = function (pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" + typeof pathObject.root);\n  }\n\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\n  var base = pathObject.base || '';\n  return dir + base;\n};\n\nposix.parse = function (pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\"Parameter 'pathString' must be a string, not \" + typeof pathString);\n  }\n\n  var allParts = posixSplitPath(pathString);\n\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n\n  allParts[1] = allParts[1] || '';\n  allParts[2] = allParts[2] || '';\n  allParts[3] = allParts[3] || '';\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\nposix.sep = '/';\nposix.delimiter = ':';\nif (isWindows) module.exports = win32;else\n  /* posix */\n  module.exports = posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;","map":null,"metadata":{},"sourceType":"script"}