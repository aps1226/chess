{"ast":null,"code":"import { getPieces, getTurns, getBoardSquares, getGameStatus, getSelection, getCastle } from '../state/state.selector';\nimport * as PiecesActions from '../state/state.actions';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nimport * as i2 from \"../services/piece.service\";\nimport * as i3 from \"@angular/cdk/drag-drop\";\nexport let BoardPieceComponent = /*#__PURE__*/(() => {\n  class BoardPieceComponent {\n    constructor(store, pieceService) {\n      this.store = store;\n      this.pieceService = pieceService;\n      this.pieces = [];\n      this.boardSquares = [];\n      this.turns = 0;\n\n      this.renderPosition = (point, dragRef) => {\n        // Render piece in appropriate position based on which move\n        // the piece is dragged, or dropped, closest to.\n        let resPoint = this.pieceService.renderPosition(point, this.piece, this.selection.moves);\n        return resPoint;\n      };\n\n      this.piece$ = this.store.select(getPieces);\n      this.piece$.subscribe(piece$ => this.pieces = [...piece$]);\n      this.boardSquare$ = this.store.select(getBoardSquares);\n      this.boardSquare$.subscribe(boardSquare$ => this.boardSquares = [...boardSquare$]);\n      this.turn$ = this.store.select(getTurns);\n      this.turn$.subscribe(turn$ => this.turns = turn$);\n      this.gameStatus$ = this.store.select(getGameStatus);\n      this.gameStatus$.subscribe(gameStatus$ => this.gameStatus = gameStatus$);\n      this.selection$ = this.store.select(getSelection);\n      this.selection$.subscribe(selection$ => this.selection = selection$);\n      this.castlePieces$ = this.store.select(getCastle);\n      this.castlePieces$.subscribe(castlePieces$ => this.castlePieces = castlePieces$);\n    }\n\n    ngOnInit() {}\n\n    handleMouseDown(event) {\n      // Get all possible moves for the respective piece.\n      const posMoves = this.pieceService.getPossibleMoves(this.piece, this.pieces); // Filter moves that would be respective king in check.\n\n      const moves = this.pieceService.filterMoves(this.piece, posMoves, this.pieces, this.boardSquares); // Add current position to moves array.\n\n      const curPos = this.boardSquares.filter(({\n        square\n      }) => square === this.piece.location)[0];\n      moves.push(curPos); // Update state of current selection.\n\n      const curSelection = Object.assign(Object.assign({}, this.piece), {\n        moves: [...moves]\n      });\n      this.store.dispatch(PiecesActions.modifySelection({\n        selection: curSelection\n      }));\n    }\n\n    handleDrop(event) {\n      const newLocation = event.container.data; // Base case if piece is not moved.\n\n      if (this.piece.location === newLocation) return;\n      this.updateState(newLocation);\n    }\n\n    updateState(newLocation) {\n      // Increment turns.\n      this.store.dispatch(PiecesActions.incrementTurn()); // Reposition dropped piece.\n\n      const newPiece = Object.assign(Object.assign({}, this.piece), {\n        location: newLocation,\n        moved: true\n      });\n      this.store.dispatch(PiecesActions.modifyPiece({\n        piece: newPiece,\n        turns: this.turns\n      })); // Determine if a piece has been captured.\n\n      const capturedPiece = this.pieces.filter(({\n        location,\n        name\n      }) => {\n        return location === newLocation && name !== this.piece.name;\n      })[0]; // If a piece has been captured, remove from state.\n\n      if (capturedPiece) {\n        const {\n          name\n        } = capturedPiece;\n        this.store.dispatch(PiecesActions.removePiece({\n          pieceName: name\n        }));\n      } // Game status state.\n\n\n      const playersTurn = this.turns % 2 === 0 ? 'white' : 'black';\n      const newGameStatus = {\n        'white': {\n          'check': false,\n          'checkMate': false\n        },\n        'black': {\n          'check': false,\n          'checkMate': false\n        }\n      }; // Determine if opponent's king is now in check.\n\n      newGameStatus[playersTurn]['check'] = this.pieceService.inCheck(this.pieces, this.boardSquares); // Determine if opponent's king is now in check-mate.\n\n      let checkMate = false;\n\n      if (newGameStatus[playersTurn]['check']) {\n        checkMate = this.pieceService.inCheckMate(this.turns, this.pieces, this.boardSquares);\n      }\n\n      ;\n      newGameStatus[playersTurn]['checkMate'] = checkMate; // Update Check state based on result.\n\n      this.store.dispatch(PiecesActions.modifyGameStatus({\n        gameStatus: newGameStatus\n      }));\n    }\n\n    handleDoubleClick() {\n      // Update castle state.\n      this.store.dispatch(PiecesActions.modifyCastle({\n        piece: this.selection\n      }));\n      const playersTurn = this.turns % 2 === 0 ? 'white' : 'black'; // If not in check, castle.\n\n      const inCheck = this.gameStatus[playersTurn]['check'];\n      if (!inCheck) this.pieceService.castle(this.castlePieces[playersTurn]);\n    }\n\n  }\n\n  BoardPieceComponent.ɵfac = function BoardPieceComponent_Factory(t) {\n    return new (t || BoardPieceComponent)(i0.ɵɵdirectiveInject(i1.Store), i0.ɵɵdirectiveInject(i2.PieceService));\n  };\n\n  BoardPieceComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: BoardPieceComponent,\n    selectors: [[\"app-board-piece\"]],\n    inputs: {\n      piece: \"piece\"\n    },\n    decls: 2,\n    vars: 3,\n    consts: [[\"cdkDrag\", \"\", 3, \"cdkDragData\", \"cdkDragConstrainPosition\", \"cdkDragDropped\", \"mousedown\", \"dblclick\"], [1, \"piece\", 3, \"src\"]],\n    template: function BoardPieceComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"cdkDragDropped\", function BoardPieceComponent_Template_div_cdkDragDropped_0_listener($event) {\n          return ctx.handleDrop($event);\n        })(\"mousedown\", function BoardPieceComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.handleMouseDown($event);\n        })(\"dblclick\", function BoardPieceComponent_Template_div_dblclick_0_listener() {\n          return ctx.handleDoubleClick();\n        });\n        i0.ɵɵelement(1, \"img\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"cdkDragData\", ctx.piece)(\"cdkDragConstrainPosition\", ctx.renderPosition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵpropertyInterpolate(\"src\", ctx.piece.src, i0.ɵɵsanitizeUrl);\n      }\n    },\n    directives: [i3.CdkDrag],\n    styles: [\".piece[_ngcontent-%COMP%]{width:100%;height:100%;display:block;margin-left:auto;margin-right:auto}.piece-box-text[_ngcontent-%COMP%]{position:absolute;bottom:0px;right:0px;font-size:12px;color:#444;opacity:.9}.cdk-drag-preview[_ngcontent-%COMP%]{opacity:0}\"]\n  });\n  return BoardPieceComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}